'''
10 most common algo questions: https://www.youtube.com/watch?v=r1MXwyiGi_U&list=WL&index=6

1- DFS: use recursion. mark the v as visited. loop through possible connection through v that are not visited and recurse
2 - BFS: use a stack. take the starting node. add all its childeren, and see if we found the target. if not mark the node as visited, pop it out and add the childeren of the first node remaining in the stack
3- matching bracket problem
4- hash tables
5- tracking two pointers/indexes: moving through a string to identify a palindrom 
6- reversed linked list and handle loops
7- sorting - quick/merge
8- recursion
9- construct a data structure
10- binary search
'''


##############################################################################################################################

'''
Given an integer array nums, you need to find one continuous subarray that if you only sort this 
subarray in ascending order, then the whole array will be sorted in ascending order.

Return the shortest such subarray and output its length.

 

Example 1:

Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
'''
class Solution:
    def findUnsortedSubarray(self, N: List[int]) -> int:
        lenN, left, right = len(N) - 1, -1, -1
        maxN, minN = N[0], N[lenN]
        for i in range(1, len(N)):
            a, b = N[i], N[lenN-i]
            if a < maxN: right = i
            else: maxN = a
            if b > minN: left = i
            else: minN = b
        return max(0, left + right - lenN + 1)

##############################################################################################################################
'''
Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.

Return the quotient after dividing dividend by divisor.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.
'''

class Solution:
    def divide(self, dividend: int, divisor: int) -> int:    
        
        sign = -1 if ((dividend < 0) ^  (divisor < 0)) else 1 # find the result's sign
        quotient = 0
        
        dividend = abs(dividend)
        divisor = abs(divisor)
        
        while (dividend >= divisor):
            quotient += 1
            dividend -= divisor
            
        return quotient * sign


class Solution2: # https://www.youtube.com/watch?v=htX69j1jf5U
    def divide(self, dividend: int, divisor: int) -> int:    
        
        sign = (-1 if((dividend < 0) ^ 
                  (divisor < 0)) else 1);
     
        # remove sign of operands
        dividend = abs(dividend);
        divisor = abs(divisor);

        # Initialize
        # the quotient
        quotient = 0;
        temp = 0;

        # test down from the highest 
        # bit and accumulate the 
        # tentative value for valid bit
        for i in range(31, -1, -1):
            if (temp + (divisor << i) <= dividend):
                temp += divisor << i;
                quotient |= 1 << i;

        return sign * quotient;




##############################################################################################################################

'''
Check if two strings can be made equal by swapping one character among each other
Difficulty Level : Basic
 Last Updated : 28 Nov, 2019
Given two strings A and B of length N, the task is to check whether the two strings can be made equal by swapping any character 
of A with any other character of B only once.

Examples:

Input: A = “SEEKSFORGEEKS”, B = “GEEKSFORGEEKG”
Output: Yes
“SEEKSFORGEEKS” and “GEEKSFORGEEKG”
can be swapped to make both the strings equal.

Input: A = “GEEKSFORGEEKS”, B = “THESUPERBSITE”
Output: No

Recommended: Please try your approach on {IDE} first, before moving on to the solution.
Approach: First omit the elements which are the same and have the same index in both the strings. Then if the new strings are of 
length two and both the elements in each string are the same then only the swap is possible.


'''



##############################################################################################################################

'''
Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

A string is called palindrome if is one that reads the same backward as well as forward.

sol.
result is 0, 1 or 2. if s is empty then 0. if there exisits a palindrome then 1, else 2 (We can remove any of the two subsequences to 
get a unary string. A unary string is always palindrome.)
'''
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if s == '':
            return 0
        elif self.isPalindrome(s):
            return 1
        else:
            return 2
        
    def isPalindrome(self, s):
        n = len(s)
        i, j = 0, n-1
        while i <= j:
            if s[i] != s[j]:
                return False
            i += 1
            j -= 1
        return True

##############################################################################################################################
'''
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest 
number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.

 

Example 1:

Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
'''

Naive greedy won't work.
Consider the case where coins = [3,7], amount = 16.
Keep track of dp[c][i] meaning the smallest number of coins to make amount i using the first c coins.
dp[0][0] = 0 and dp[0][i] = inf for i > 0.
dp[c+1][i] is the smaller of dp[c][i] -- not making use of the (c+1)-th coin; or dp[c+1][i-coins[c]] + 1 -- add one more c-th coin to the best solution that makes up an amount of i-coins[c] using only the first c coins.
No need to actually maintain space for a 2-D array if we iterate along c.
Code

class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [0] + [inf] * amount
        for x in coins:
            for i in range(amount - x + 1):
                dp[i + x] = min(dp[i + x], dp[i] + 1)
        return dp[amount] if dp[amount] != inf else -1
##############################################################################################################################

'''
Given a binary string s and an integer k.

Return True if every binary code of length k is a substring of s. Otherwise, return False.

 

Example 1:

Input: s = "00110110", k = 2
Output: true
Explanation: The binary codes of length 2 are "00", "01", "10" and "11". They can be all found as substrings at indicies 0, 1, 3 and 2 respectively.
'''

class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        us = set()
        for i in range(len(s) -k + 1) :    
            us.add(s[i : k+i])    
        return len(us) == 1 << k



########################################################################################################################

'''
Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.

We make a binary tree using these integers, and each number may be used for any number of times. 
Each non-leaf node's value should be equal to the product of the values of its children.

Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.


dea:

The trick to this problem is realizing that we can break it down into smaller pieces. A number can always be a leaf, 
so the number of ways it can form a branch should always start at 1.

If the number can be made from multiple factor pairs, then ways is our starting value of 1 plus the sum of all the ways 
to make those factor pairs.

For each existing factor pair (fA & fB), the number of ways to make that that particular pair configuration is the product 
of the number of ways to make fA and fB.

So we can see that each number relies on first solving the same question for each of its factors. This means that we should 
start by sorting our numbers array (A). Then we can iterate through A and figure out each number in ascending order, so that 
we will have completed any factors for larger numbers before we need to use them.

This means storing the information, which we can do in a map, so that we can look up the results by value.

In order to be more efficient when we attempt to find each factor pair, we only need to iterate through A up to the square 
root of the number in question, so that we don't duplicate the same factor pairs going the opposite direction. That means 
we need to double every pair result where fA and fB are not the same.

Since each number can be the head of a tree, our answer (ans) will be the sum of each number's result. We shouldn't forget 
to modulo at each round of summation.
'''

class Solution:
    def numFactoredBinaryTrees(self, A: List[int]) -> int:
        A.sort()
        fmap, ans = defaultdict(), 0
        for num in A:
            ways, lim = 1, sqrt(num)
            for fA in A:
                if fA > lim: break
                fB = num / fA
                if fB in fmap:
                    ways += fmap[fA] * fmap[fB] * (1 if fA == fB else 2)
            fmap[num], ans = ways, (ans + ways)
        return ans % 1000000007


########################################################################################################################
'''
You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.

One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's 
width and height.

Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).

sol: sort based on width. if width are equal prioritize the larger height.
using bisect_left : it will show the left most index in dp where current height has to be based on a sorted list.
for instance if dp = [3, 4, 7], and h = 8, idx = 3
for instance if dp = [3, 4, 7], and h = 2, idx = 0
for instance if dp = [3, 4, 7], and h = 4, idx = 1
'''

class Solution:
    def maxEnvelopes(self, E: List[List[int]]) -> int:
        E.sort(key=lambda x: (x[0], -x[1]))
        dp = []
        for _,height in E:
            left = bisect_left(dp, height)
            if left == len(dp): dp.append(height)
            else: dp[left] = height
        return len(dp)        

########################################################################################################################
'''
Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.

The answer is guaranteed to fit in a 32-bit integer.

 

Example 1:

Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Example 2:

Input: nums = [9], target = 3
Output: 0
 ‍۱
'''



class Solution:
    def combinationSum4(self, N: List[int], T: int) -> int:
        dp = [0] * (T + 1)
        dp[0] = 1
        for i in range(1, T+1):
            for num in N:
                if num <= i: 
                    dp[i] += dp[i-num]
                    print(i,num, dp)
                    
        return dp[T]


########################################################################################################################

'''
Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

Example 1:

Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".

Notice that some of these substrings repeat and are counted the number of times they occur.

Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
'''


class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        curr, prev, ans = 1, 0, 0
        for i in range(1, len(s)):
            if s[i] == s[i-1]: curr += 1
            else:
                ans += min(curr, prev)
                prev, curr = curr, 1
        return ans + min(prev,curr) 

########################################################################################################################

               
'''
Matchsticks to Square


You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. 
You want to use all the matchsticks to make one square. You should not break any stick, but you can 
link them up, and each matchstick must be used exactly one time.

Return true if you can make this square and false otherwise.

Example:

Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.

https://www.youtube.com/watch?v=Amfd1bqZmVg

'''

class Solution:
    def makesquare(self, matchsticks: List[int]) -> bool:
        n = len(matchsticks)
        circumvent = sum(matchsticks)        
        if circumvent % 4 != 0:
            return False
        squareSide_size = circumvent//4
        matchsticks.sort(reverse=True)#first check the larger sticks, it makes it faster
        def dfs(a,b,c,d,i): #a,b,c,d are the sides that should be equal. i is the index of the stick
            if i == n: # if all the matches are visited
                if a==b==c==d:
                    return True
                return False
            stick_i = matchsticks[i]
            
            #check to see if you add a stick to each side would it match the squareSide_size
            if a + stick_i <= squareSide_size and dfs(a + stick_i, b, c, d, i+1):
                return True
            if b + stick_i <= squareSide_size and dfs(a, b + stick_i, c, d, i+1):
                return True
            if c + stick_i <= squareSide_size and dfs(a, b, c + stick_i, d, i+1):
                return True
            if d + stick_i <= squareSide_size and dfs(a, b, c, d + stick_i, i+1):
                return True
            
            return False
        
        return dfs(0,0,0,0,0)
            
########################################################################################################################


